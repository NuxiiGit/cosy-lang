-- function definition
let max (a : i32) (b : i32) : i32 = if a > b { a } else { b };

-- function application
var greatest = max 3 4;

-- lambda function
let lambda : i32 -> i32 = \x -> x * 2;

-- block lambda function
let lambda' : i32 -> i32 = \x -> {
	return x + x;
};

-- delayed function definition
var max' : i32 -> i32 -> i32;
max' = \a \b -> max a b;

-- nullary function (pass-by-name)
var message : -> String = -> shuffle "hello world";

-- currying
let positive : i32 -> i32 = max 1;

-- procedural style functions
let izard (a : String, b : String) : String {
	return a ++ " fo' " ++ b ++ "izard";
}

var message = izard ("bash", "sh");

-- implicit return (final `;` not required)
let wizard () {
	-- "flowers fo' wizard"
	izard ("flowers", "wi")
}

-- placeholder arguments
var array_decrement = filter ("prefix" + _);

{- The `_` represents a location where an argument can be placed.
 - Since operators always apply the right-hand-side parameter first, this
 - behaviour is required to partially apply the left-hand-side of an operator
 - instead.
 -}

-- sequent style formatting seen in proof languages
let sequent_style
		(n : i32)
		(s : String)
		------------
		: bool
	= length s == n;

-- generic function which just returns the value itself
let id (x : 'a) : 'a = x;

-- functional style functions
let concat xss = case xss {
	[] => [],
	[xs, ..xss] => xs ++ concat xss
};