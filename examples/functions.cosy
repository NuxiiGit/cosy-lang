-- function definition
let max(a : i32, b : i32) : i32 = if a > b { a } else { b }

-- function application
let greatest = max(3, 4)

-- lambda function
let f : i32 -> i32 = \x -> x * 2
let f' : i32 -> i32 = \x -> {
	let a = x + x;
	a
}

-- delayed function definition
let max' : (i32, i32) -> i32
max' = \(a, b) -> max(a, b)

-- currying
let curry(f : ('a, 'b) -> 'c)(a : 'a)(b : 'b) : 'c = f(a, b)
let max_curried : i32 -> i32 -> i32 = curry(max)
max_curried(1)(3)

-- operator definition
let (a : i32) <=> (b : i32) : i32 = Math::sign(a - b)

-- identity operator
let (f : 'a -> 'b) $ (x : 'a) : 'b = f(x)
let greatest' = (max_curried $ 2) $ 1

-- pipeline operator
let (x : 'a) |> (f : 'a -> 'b) : 'b = f $ x
let greatest'' = 1 |> (2 |> max_curried)

-- procedural style functions
let izard(a : str, b : str) : str = {
	return a ++ "izard" ++ b
}

-- sequent style functions
let proof (n : i32)
          (s : str)
          ---------
          : bool
          = n == s.length()

-- functional style functions
let concat(xss : [['a]]) : ['a] = case xss {
	[]          = []
	[xs, ..xss] = xs ++ concat(xss)
}

-- operator blocks (allow the use of expressions or non-operator identifiers as operators)
let (min : i32) `clamp(x : i32)` (max : i32) : i32 = if x > max { max } else if x < min { min } else { x }
let percent = 0 `clamp(x)` 100

-- constant function (functions must be pure to qualify as constants)
let const double(a : i32) : i32 = 2 * a  -- let const double : i32 -> i32 = \(a : i32) -> 2 * a
let const pi_2 = double(pi)              -- evaluated at compile time
