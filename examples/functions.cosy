-- function definition
fn max(a : i32, b : i32) : i32 = if a > b do { a } else { b };

-- function application
let greatest = max(3, 4);

-- lambda function
fn double  : i32 -> i32 = \(x) => x * 2;
fn double' : i32 -> i32 = \(x) => do {
	let a = x + x;
	a
};

-- curried lambda function
fn f : i32 -> i32 -> i32 = \(x)(y) => x + y;
                     -- OR \(x) => \(y) => x + y

-- parameterised function
fn id[a : type](x : a) : a = x;

-- currying
fn curry[a : type, b : type, c : type](f : (a, b) -> c)(x : a)(y : b) : c = f(x, y);
fn max_curried : i32 -> i32 -> i32 = curry(max);
max_curried(1)(3);

-- operator definition
fn (a : i32) <=> (b : i32) : i8 = if a < b do { -1 } else if a > b do { 1 } else { 0 };

-- operator blocks (allow the use of expressions or non-operator identifiers as operators)
fn (min : i32) `clamp(x : i32)` (max : i32) : i32 = if x > max do { max } else if x < min do { min } else { x };
let percent = 0 `clamp(x)` 100;

-- pipeline operator
fn (|>)[a : type, b : type] : (a -> b) -> (a -> b) = id;
let greatest'' = 1 |> (2 |> max_curried);

-- procedural style functions
fn izard(s : str, t : str) : str = do {
	return s ++ "izard" ++ t;
};

-- sequent style functions
fn proof (n : i32)
         (s : str)
         ---------
         : bool
         = n == s.length();

-- constant function
const fn factorial(n : u32) : u32 = case n in {
	0 => 1,
	1 => 1,
	_ => factorial(n) + factorial(n - 1)
};
let fact_32 = factorial(32); -- evaluated at compile time, since the value is constant

-- constrained dependent values (divisor must be constant)
fn safe_divide[divisor : i32](dividend : i32) : i32 where divisor != 0 = dividend / divisor;

-- type functions/compile-time functions
const fn If[condition : bool, a : type, b : type] : type = if condition do { a } else { b };

-- dependently typed function
fn (-)[is_unary : bool](x : i32) : If[is_unary, i32, i32 -> i32] = do {
	let inverse = neg(x);
	if is_unary do {
		inverse
	} else {
		\(y) => y + inverse
	}
};