-- function definition
let max (a : i32) (b : i32) : i32 = if a > b { a } else { b };

-- function application
var greatest = max 3 4;

-- lambda function
let lambda : i32 -> i32 = \x -> x * 2;

-- block lambda function
let lambda' : i32 -> i32 = \x -> {
	return x + x;
};

-- delayed function definition
var max' : i32 -> i32 -> i32;
max' = \a \b -> max a b;

-- nullary function (pass-by-name)
var message : -> String = -> shuffle "hello world";

-- currying
let positive : i32 -> i32 = max 1;

-- procedural style functions
let izard (a : String, b : String) : String {
	return a ++ " fo' " ++ b ++ "izard";
}

var message = izard ("bash", "sh");

-- implicit return (final `;` not required)
let wizard () {
	-- "flowers fo' wizard"
	izard ("flowers", "wi")
}

-- placeholder arguments
var array_decrement = filter (-1);    -- this doesn't give the result you would expect; calling operators prefixed subsitutes the left-most argument first
                                      -- so you end up with `filter (\x -> 1 - x)` which is incorrect
var array_decrement = filter (_ - 1); -- this gives the correct result, subsituted into the second parameter of the operator section
                                      -- so you end up with `filter (\x -> x - 1)` which is correct

-- sequent style formatting seen in proof languages
let sequent_style
		(n : i32)
		(s : String)
		------------
		: bool
	= length s == n;

-- generic function which just returns the value itself
let id (x : 'a) : 'a = x;

-- functional style functions
let concat xss = case xss {
	[] => [],
	[xs, ..xss] => xs ++ concat xss
};