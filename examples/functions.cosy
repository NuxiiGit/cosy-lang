-- function definition
let max(a : i32, b : i32) : i32 = if a > b { a } else { b };

-- function application
let greatest : i32 = max(3, 4);

-- lambda function
let double  : i32 -> i32 = \(x) => x * 2;
let double' : i32 -> i32 = \(x) => do {
	let a = x + x;
	a
};

-- curried lambda function
let f : i32 -> i32 -> i32 = \(x)(y) => x + y;
                      -- OR \(x) => \(y) => x + y

-- parameterised function
let id{a : type}(x : a) : a = x;

-- currying
let curry{a : type, b : type, c : type}(f : (a, b) -> c)(x : a)(y : b) : c = f(x, y);
let max_curried : i32 -> i32 -> i32 = curry(max);
max_curried(1)(3);

-- operator definition
let (a : i32) <=> (b : i32) : i32 = if a < b { -1 } else if a > b { 1 } else { 0 };

-- operator blocks (allow the use of expressions or non-operator identifiers as operators)
let (min : i32) `clamp(x : i32)` (max : i32) : i32 = if x > max { max } else if x < min { min } else { x };
let percent : i32 = 0 `clamp(x)` 100;

-- identity operator
let (f : a -> b) `($){a : type, b : type}` (x : a) : b = f(x);
let greatest' : i32 = (max_curried $ 2) $ 1;

-- pipeline operator
let (x : a) `(|>){a : type, b : type}` (f : a -> b) : b = f(x);
let greatest'' : i32 = 1 |> (2 |> max_curried);

-- procedural style functions
let izard(a : str, b : str) : str = do {
	return a ++ "izard" ++ b;
};

-- sequent style functions
let proof (n : i32)
          (s : str)
          ---------
          : bool
          = n == s.length();

-- functional style functions
let concat{a : type}(xss : [[a]]) : [a] = case xss {
	[]          => [],
	[xs, ..xss] => xs ++ concat(xss)
};

-- impure function functions must be pure under certain circumstances, typically if they have side-effects
let impure notify(a : i32) : i32 = do {
	print(a);  -- printing and file input/output is an impure side-effect
	a
};

-- implicit argument with a default value
let {l : i32 = 0} - (r : i32) : i32 = subtract(l, r);  -- assuming `subtract` is a function which subtracts two `i32`
let result : i32        = -10;  -- implicit argument should be assigned to `0`
let result : i32 -> i32 = -10;  -- implicit argument should become a concrete argument
-- why does this need to be implemented?
-- this must be implemented because it will allow for compile-time function overloading without poluting global scope with identifiers of the same name
-- i.e. `let (-) : i32 = 3;` will be invalid, since the identifier `-` already exists. This would not be the case with Idris.