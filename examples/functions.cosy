-- function definition
fn max(a : i32, b : i32) : i32 = if a > b do { a } else { b };

-- function application
let greatest = max(3, 4);

-- lambda function
fn double  : i32 -> i32 = \(x) => x * 2;
fn double' : i32 -> i32 = \(x) => do {
	let a = x + x;
	a
};

-- curried lambda function
fn f : i32 -> i32 -> i32 = \(x)(y) => x + y;
                     -- OR \(x) => \(y) => x + y

-- parameterised function
fn id|a : type|(x : a) : a = x;

-- currying
fn curry|a : type, b : type, c : type|(f : (a, b) -> c)(x : a)(y : b) : c = f(x, y);
fn max_curried : i32 -> i32 -> i32 = curry(max);
max_curried(1)(3);

-- operator definition
fn (a : i32) <=> (b : i32) : i8 = if a < b do { -1 } else if a > b do { 1 } else { 0 };

-- operator blocks (allow the use of expressions or non-operator identifiers as operators)
fn (min : i32) `clamp(x : i32)` (max : i32) : i32 = if x > max do { max } else if x < min do { min } else { x };
let percent = 0 `clamp(x)` 100;

-- pipeline operator
fn (|>)|a : type, b : type| : (a -> b) -> (a -> b) = id;
let greatest'' = 1 |> (2 |> max_curried);

-- procedural style functions
fn izard(s : str, t : str) : str = do {
	return s ++ "izard" ++ t;
};

-- sequent style functions
fn proof (n : i32)
         (s : str)
         ---------
         : bool
         = n == s.length();

-- functional style functions
fn concat|a : type|(xss : [[a]]) : [a] = case xss in {
	[]          => [],
	[xs, ..xss] => xs ++ concat(xss)
};

-- dependently typed function
fn (-)|is_unary : bool|(x : i32) : if is_unary do { i32 } else { i32 -> i32 } = do {
	let inverse = neg(x);
	if is_unary do {
		inverse
	} else {
		\(y) => y + inverse
	}
};

-- constant function
const fn fib(n : u32) : u32 = case n in {
	0 => 1,
	1 => 1,
	x => x + fib(x - 1)
};
let fib_24 = fib(24);  -- 46368 (evaluated at compile-time)