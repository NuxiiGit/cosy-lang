-- function definition
let max(a : i32, b : i32) : i32 = if a > b { a } else { b };

-- function application
var greatest = max(3, 4);

-- lambda function
let f : i32 -> i32 = \x -> x * 2;
let f' : i32 -> i32 = \x -> {
	print(x);
	x + x
}

-- delayed function definition
var max' : (i32, i32) -> i32;
max' = \(a, b) -> max(a, b);

-- currying
let curry(f : ('a, 'b) -> 'c)(a : 'a)(b : 'b) : 'c = f(a, b);
var max_curried : i32 -> i32 -> i32 = curry(max);
max_curried(1)(3);

-- operator definition
let (a : i32) <=> (b : i32) : i32 = Math::sign(a - b);

-- pipeline operator
let (f : 'a -> 'b) |> (x : 'a) : 'b = f(x);
var greatest' = max_curried |> 2 |> 1;

-- procedural style functions
let izard(a : str, b : str) : str = {
	return a ++ "izard" ++ b;
}

-- sequent style functions
let proof (n : i32)
          (s : str)
          ---------
          : bool
          = n = s.length();

-- functional style functions
let concat(xss : [['a]]) : ['a] = case xss {
	[]          = [],
	[xs, ..xss] = xs ++ concat(xss)
}

-- operator blocks (allow the use of expressions or non-operator identifiers as operators)
let clamp(x : i32)(max : i32)(min : i32) : i32 = if x > max { max } else if x < min { min } else { x };
var percent = 0 `clamp(x)` 100;