-- function definition
let max(a : i32, b : i32) : i32 = if a > b { a } else { b }

-- function application
let greatest : i32 = max(3, 4)

-- lambda function
let double  : i32 -> i32 = \x -> x * 2
let double' : i32 -> i32 = \x -> do {
	let a = x + x
	a
}

-- parameterised function
let id{a : type}(x : a) : a = x

-- currying
let curry{a : type, b : type, c : type}(f : (a, b) -> c)(x : a)(y : b) : c = f(x, y)
let max_curried : i32 -> i32 -> i32 = curry(max)
max_curried(1)(3)

-- operator definition
let (a : i32) <=> (b : i32) : i32 = Math::sign(a - b)

-- identity operator
let (f : 'a -> 'b) $ (x : 'a) : 'b = f(x)
let greatest' = (max_curried $ 2) $ 1

-- pipeline operator
let (x : 'a) |> (f : 'a -> 'b) : 'b = f $ x
let greatest'' = 1 |> (2 |> max_curried)

-- procedural style functions
let izard(a : str, b : str) : str = do {
	return a ++ "izard" ++ b
}

-- sequent style functions
let proof (n : i32)
          (s : str)
          ---------
          : bool
          = n == s.length()

-- functional style functions
let concat(xss : [['a]]) : ['a] = case xss {
	[]          = [],
	[xs, ..xss] = xs ++ concat(xss)
}

-- operator blocks (allow the use of expressions or non-operator identifiers as operators)
let (min : i32) `clamp(x : i32)` (max : i32) : i32 = if x > max { max } else if x < min { min } else { x }
let percent = 0 `clamp(x)` 100

-- constant function (functions must be pure to qualify as constants)
let const double(a : i32) : i32 = 2 * a  -- let const double : i32 -> i32 = \(a : i32) -> 2 * a
let const pi_2 = double(pi)              -- evaluated at compile time
