-- function definition
def max = fn(a : i32, b : i32) : i32 => if a > b { a } else { b };

-- function application
let greatest = max(3, 4);

-- lambda function
def double  = fn(x : i32) : i32 => x * 2;
def double' = fn(x : i32) : i32 => {
    let a = x + x;
    a
};

-- curried lambda function
def f = fn(x : i32) => fn(y : i32) : i32 => x + y;

-- parameterised function
def id[a : type] = fn(x : a) : a => x;

-- currying
def curry[a : type, b : type, c : type] = fn(f : a & b -> c) => fn(x : a) => fn(y : b) : c => f(x, y);
def max_curried = curry(max);
max_curried(1)(3);

-- operator definition
def (<=>) = fn(a : i32, b : i32) : i8 => if a < b { -1 } else if a > b { 1 } else { 0 };

-- pipeline operator
def (|>)[a : type, b : type] = id[a -> b];
let greatest'' = 1 |> (2 |> max_curried);

-- procedural style functions
def izard = fn(s : str, t : str) : str => {
    return s ++ "izard" ++ t;
};

-- functional style function
def is_less_than_5 = fn(n : u8) : bool => match n {
    0;  -- fallthrough matching case
    1;
    2;
    3;
    4 = true;
    _ = false;
};

-- sequent style functions
def proof = fn (n : i32)
               (s : str)
               ---------
               : bool
               => n == len(s);

-- pure function
pure def factorial = fn(n : u32) : u32 => match n {
    0;  -- fallthrough case
    1 = 1;
    _ = factorial(n - 1) + factorial(n - 2);
};
let fact_32      = factorial(32);      -- evaluated at compile time, since the value is constant
let fact_fact_32 = factorial(fact_32); -- not evaluated at compile time, since `fact_32` is not a `def` (constant)

-- strictly compile-time functions ("macros")
def choice[condition : bool, a : type, b : type] : type = if condition { a } else { b };

-- type functions
pure def apply = fn(f : type -> type, a : type) : type = f(a);
pure def make_pair = fn(a : type) : type = a & a;
def vec2 = apply(make_pair, f32);  -- produces the type `f32 & f32`
