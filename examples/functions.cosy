-- function definition
let max(a : i32, b : i32) : i32 = if a > b { a } else { b }

-- function application
let greatest : i32 = max(3, 4)

-- lambda function
let double  : i32 -> i32 = \x -> x * 2
let double' : i32 -> i32 = \x -> do {
	let a = x + x
	a
}

-- parameterised function
let id{a : type}(x : a) : a = x

-- currying
let curry{a : type, b : type, c : type}(f : (a, b) -> c)(x : a)(y : b) : c = f(x, y)
let max_curried : i32 -> i32 -> i32 = curry(max)
max_curried(1)(3)

-- operator definition
let (a : i32) <=> (b : i32) : i32 = if a < b { -1 } else if a > b { 1 } else { 0 }

-- operator blocks (allow the use of expressions or non-operator identifiers as operators)
let (min : i32) `clamp(x : i32)` (max : i32) : i32 = if x > max { max } else if x < min { min } else { x }
let percent : i32 = 0 `clamp(x)` 100

-- identity operator
let (f : a -> b) `($){a : type, b : type}` (x : a) : b = f(x)
let greatest' : i32 = (max_curried $ 2) $ 1

-- pipeline operator
let (x : a) `(|>){a : type, b : type}` (f : a -> b) : b = f(x)
let greatest'' : i32 = 1 |> (2 |> max_curried)

-- procedural style functions
let izard(a : str, b : str) : str = do {
	return a ++ "izard" ++ b
}

-- sequent style functions
let proof (n : i32)
          (s : str)
          ---------
          : bool
          = n == s.length()

-- functional style functions
let concat{a : type}(xss : [[a]]) : [a] = case xss {
	[]          = [],
	[xs, ..xss] = xs ++ concat(xss)
}

-- impure function functions must be pure under certain circumstances, typically if they have side-effects
let impure notify(a : i32) : i32 = do {
	print(a) -- printing and file input/output is an impure side-effect
	a
}