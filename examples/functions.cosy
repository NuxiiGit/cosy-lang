-- function definition
let max(a : i32, b : i32) : i32 = if a > b do { a } else { b };

-- function application
let greatest : i32 = max(3, 4);

-- lambda function
let double  : i32 -> i32 = \(x) => x * 2;
let double' : i32 -> i32 = \(x) => do {
	let a = x + x;
	a
};

-- curried lambda function
let f : i32 -> i32 -> i32 = \(x)(y) => x + y;
                      -- OR \(x) => \(y) => x + y

-- parameterised function
let id(a : type)?(x : a) : a = x;

-- currying
let curry(a : type, b : type, c : type)?(f : (a, b) -> c)(x : a)(y : b) : c = f(x, y);
let max_curried : i32 -> i32 -> i32 = curry(max);
max_curried(1)(3);

-- operator definition
let (a : i32) <=> (b : i32) : i32 = if a < b do { -1 } else if a > b do { 1 } else { 0 };

-- operator blocks (allow the use of expressions or non-operator identifiers as operators)
let (min : i32) `clamp(x : i32)` (max : i32) : i32 = if x > max do { max } else if x < min do { min } else { x };
let percent : i32 = 0 `clamp(x)` 100;

-- identity operator
let (f : a -> b) $ (x : a) : b = f(x);
let greatest' : i32 = (max_curried $ 2) $ 1;

-- pipeline operator
let (x : a) |> (f : a -> b) : b = f(x);
let greatest'' : i32 = 1 |> (2 |> max_curried);

-- procedural style functions
let izard(a : str, b : str) : str = do {
	return a ++ "izard" ++ b;
};

-- sequent style functions
let proof (n : i32)
          (s : str)
          ---------
          : bool
          = n == s.length();

-- functional style functions
let concat(a : type)?(xss : [[a]]) : [a] = case xss in {
	[]          => [],
	[xs, ..xss] => xs ++ concat(xss)
};

-- constant function
let const template(option : u8) : type = case option in {
	0 => bool,
	1 => i32,
	2 => f32,
	_ => void
};

-- dependently typed function
let negate(option : bool)?(x : template(option)) : template(option) = case option in {
	0 => !x,
	1 => -x,
	2 => -x,
	_ => x
};
print(negate(true));  -- false
print(negate(2));     -- -2
print(negate(-3.2));  -- 3.2

-- unary/binary operator duality
let (-)(is_unary : bool)?(x : i32) : if is_unary { i32 } else { i32 -> i32 } = do {
	let inverse = negate(x);
	if is_unary do {
		inverse
	} else {
		\(y : i32) => y + inverse
	}
};