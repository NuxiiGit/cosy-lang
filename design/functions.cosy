-- function definition
def max(a : i32, b : i32) : i32 = if a > b { a } else { b };

-- function application
let greatest = max(3, 4);

-- lambda function
def double  : i32 -> i32 = x => x * 2;
def double' : i32 -> i32 = x => {
    let a = x + x;
    a
};

-- curried lambda function
def f : i32 -> i32 -> i32 = x => y => x + y

-- parameterised function
def id[a : type](x : a) : a = x;

-- currying
def curry[a : type, b : type, c : type](f : a & b -> c)(x : a)(y : b) : c = f(x, y);
def max_curried : i32 -> i32 -> i32 = curry(max);
max_curried(1)(3);

-- operator definition
def (a : i32) <=> (b : i32) : i8 = if a < b { -1 } else if a > b { 1 } else { 0 };

-- pipeline operator
def (|>)[a : type, b : type] : (a -> b) -> (a -> b) = id;
let greatest'' = 1 |> (2 |> max_curried);

-- procedural style functions
def izard(s : str, t : str) : str = {
    return s ++ "izard" ++ t;
};

-- functional style function
def is_less_than_5(n : u8) : bool = match n {
    0;  -- fallthrough matching case
    1;
    2;
    3;
    4 => true;
    _ => false;
};

-- sequent style functions
def proof (n : i32)
          (s : str)
          ---------
          : bool
          = n == len(s);

-- pure function
pure def factorial(n : u32) : u32 = match n {
    0;  -- fallthrough case
    1 => 1;
    _ => factorial(n - 1) + factorial(n - 2);
};
let fact_32      = factorial(32);      -- evaluated at compile time, since the value is constant
let fact_fact_32 = factorial(fact_32); -- not evaluated at compile time, since `fact_32` is not a `def` (constant)

-- strictly compile-time functions ("macros")
def choice[condition : bool, a : type, b : type] : type = if condition { a } else { b };

-- type functions
pure def apply(f : type -> type, a : type) : type = f(a);
pure def make_pair(a : type) : type = a & a;
def vec2 : type = apply(make_pair, f32);  -- produces the type `f32 & f32`
